<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Virtual Gulaschtreff</title>
    <style type="text/css">
        body{
            overflow: hidden;
            width:100%;
        }
        #players{
            display:flex;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
<div id="players">

</div>
<script type="application/javascript">

    class Player {
        name = 'unnamed';
        webRtcConnection = undefined;
        mediaStream = undefined;

        dispose() {
            console.log("dispose")
        }
    }

    class Players {
        players;

        constructor() {
            this.players = {};
        }

        has(id) {
            return this.players[id] !== undefined;
        }

        getName(id) {
            return this.players[id];
        }

        removePlayer(id) {
            if (this.has(id)) {
                this.players[id].dispose();
                delete (this.players[id]);
            } else {
                console.log("cannot remove unknown player:" + id)
            }
        }

        setName(id, newName) {
            if (!this.has(id)) {
                this.players[id] = new Player();
            }
            this.players[id].name = newName;
        }

        getIDs() {
            let ids = [];
            for (let id in this.players) {
                if (!this.players.hasOwnProperty(id)) {
                    continue;
                }
                ids.push(id)
            }
            return ids;
        }

        hasPlayers() {
            return this.getIDs().length > 0;
        }

        setPeerConnection(id, webRtcConnection) {
            this.get(id).webRtcConnection = webRtcConnection;
        }

        getPeerConnection(id) {
            return this.get(id).webRtcConnection;
        }

        get(id) {
            return this.players[id];
        }

        getMediaStream(id) {
            return this.get(id).mediaStream;
        }

        setMediaStream(id, mediaStream) {
            this.get(id).mediaStream = mediaStream;
        }

        disableVideo(id) {
            this.getMediaStream(id).getVideoTracks().forEach(track => track.enabled = false);
        }

        enableVideo(id) {
            this.getMediaStream(id).getVideoTracks().forEach(track => track.enabled = true);
        }

        disableAudio(id) {
            this.getMediaStream(id).getAudioTracks().forEach(track => track.enabled = false);
        }

        enableAudio(id) {
            this.getMediaStream(id).getAudioTracks().forEach(track => track.enabled = true);
        }

        hasPeerConnection(id) {
            return this.getPeerConnection(id) !== undefined;
        }
    }

    const names = ["Sioux", "Martguerita", "Janel", "Ruthy", "Arlene", "Pauly", "Flo", "Scarlett", "Gypsy", "Adel", "Edeline", "Willi", "Arlyne", "Starlin", "Tania", "Hildegaard", "Aveline", "Appolonia", "Linet", "Arabel", "Anjela", "Tyne", "Caresse", "Kylynn", "Lorenza", "Rhianon", "Nonna", "Joni", "Rachelle", "Katusha", "Sharia", "Catherine", "Kerri", "Aili", "Andra", "Margy", "Cindi", "Fanchette", "Dara", "Brittaney", "Corie", "Gilbertine"];

    const wsUrl = 'wss://' + location.host + '/ws/gt';
    let players = new Players();
    let myPlayerID = null;
    let ws = null;

    window.onerror = errorHandler;

    function getRandomName() {
        return names[Math.floor(Math.random() * Math.floor(names.length))];
    }

    function errorHandler(errorMsg, url, lineNumber) {
        alert("Error occurred: " + errorMsg + " in " + url + " line " + lineNumber);
        return false;
    }

    async function makeCall(calledPlayerID) {
        const configuration = {'iceServers': [{'urls': 'stun:stun1.l.google.com:19302'}]};
        const peerConnection = new RTCPeerConnection(configuration);
        peerConnection.addEventListener('icecandidate', event => {
            if (event.candidate) {
                const iceCandidateMessage = {
                    'Type': 'WEB_RTC_ICE_CANDIDATE',
                    'Payload': {'RemotePlayerID': calledPlayerID, 'IceCandidate': event.candidate}
                };
                try {
                    console.log("sending ice candidate");
                    ws.send(JSON.stringify(iceCandidateMessage));
                } catch (e) {
                    console.log("error sending ice candidate:", e)
                }
            }
        });
        peerConnection.addEventListener('connectionstatechange', event => {
            console.log("connectionstatechange", event);
            if (peerConnection.connectionState === 'connected') {
                console.log("Peers connected!");
            }
        });
        peerConnection.addEventListener('track', async (event) => {
            let playerMediaStream = players.getMediaStream(calledPlayerID);
            playerMediaStream.addTrack(event.track, playerMediaStream);
            document.getElementById("video_" + calledPlayerID).srcObject = playerMediaStream;
        });

        let myMediaStream = players.getMediaStream(myPlayerID);
        myMediaStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, myMediaStream);
        });

        var mediaConstraints = {
            'offerToReceiveAudio': true,
            'offerToReceiveVideo': true
        };
        const offer = await peerConnection.createOffer(mediaConstraints);
        await peerConnection.setLocalDescription(offer);


        const offerMessage = {
            'Type': 'WEB_RTC_OFFER',
            'Payload': {'RemotePlayerID': calledPlayerID, 'Offer': offer}
        };
        ws.send(JSON.stringify(offerMessage));
        players.setPeerConnection(calledPlayerID, peerConnection);
    }

    async function answerCall(callingPlayerID, offer) {
        const configuration = {'iceServers': [{'urls': 'stun:stun1.l.google.com:19302'}]};
        const peerConnection = new RTCPeerConnection(configuration);
        peerConnection.addEventListener('icecandidate', event => {
            if (event.candidate) {
                const iceCandidateMessage = {
                    'Type': 'WEB_RTC_ICE_CANDIDATE',
                    'Payload': {'RemotePlayerID': callingPlayerID, 'IceCandidate': event.candidate}
                };
                try {
                    console.log("also sending ice candidate");
                    ws.send(JSON.stringify(iceCandidateMessage));
                } catch (e) {
                    console.log("error sending ice candidate:", e)
                }
            }
        });
        peerConnection.addEventListener('connectionstatechange', event => {
            console.log("connectionstatechange", event);
            if (peerConnection.connectionState === 'connected') {
                console.log("Peers connected!");
            }
        });
        let myMediaStream = players.getMediaStream(myPlayerID);
        myMediaStream.getTracks().forEach(track => {
            peerConnection.addTrack(track, myMediaStream);
        });
        peerConnection.addEventListener('track', async (event) => {
            let playerMediaStream = players.getMediaStream(callingPlayerID);
            playerMediaStream.addTrack(event.track, playerMediaStream);
            document.getElementById("video_" + callingPlayerID).srcObject = playerMediaStream;
        });
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        const answerMessage = {
            'Type': 'WEB_RTC_ANSWER',
            'Payload': {'RemotePlayerID': callingPlayerID, 'Answer': answer}
        };
        ws.send(JSON.stringify(answerMessage));
        players.setPeerConnection(callingPlayerID, peerConnection);
    }

    async function establishConnection(remotePlayerID, answer) {
        const remoteDesc = new RTCSessionDescription(answer);
        await players.getPeerConnection(remotePlayerID).setRemoteDescription(remoteDesc);
        console.log("peer pairing done")
    }

    async function addIceCandidate(remotePlayerID, iceCandidate) {
        try {
            console.log("adding ice candidate");
            await players.getPeerConnection(remotePlayerID).addIceCandidate(iceCandidate);
        } catch (e) {
            console.error('Error adding received ice candidate', e);
        }
    }

    function newPlayer(ID) {
        let playerElement = document.createElement("div");
        playerElement.id = "player_" + ID;

        let playerLabel = document.createElement("div");
        playerLabel.id = "player_label_" + ID;
        playerLabel.innerText = players.getName(ID);
        playerElement.append(playerLabel)

        let videoElement = document.createElement("video");
        videoElement.id = "video_" + ID;
        videoElement.autoplay = "autoplay";
        videoElement.width = "300";
        videoElement.style = "background-color: black;";
        playerElement.append(videoElement);

        if (ID === myPlayerID) {
            const constraints = {
                'video': true,
                'audio': true
            };
            navigator.mediaDevices.getUserMedia(constraints)
                .then(stream => {
                    players.setMediaStream(myPlayerID, stream);
                    let myStream = players.getMediaStream(myPlayerID);
                    videoElement.srcObject = players.getMediaStream(myPlayerID);
                    videoElement.muted = true;
                })
                .catch(error => {
                    console.error('Error accessing media devices.', error);
                });

        } else {
            players.setMediaStream(ID, new MediaStream());
            videoElement.src = "/images/loading-gulasch.mp4";
        }

        let toggleVideo = document.createElement("input");
        toggleVideo.type = "checkbox"
        toggleVideo.checked = "checked"
        toggleVideo.value = "1"
        toggleVideo.id = "toggle_video_" + ID;
        toggleVideo.class = "player-media-controls--video-toggle";
        toggleVideo.addEventListener('change', (e) => e.target.checked ? players.enableVideo(ID) : players.disableVideo(ID))
        playerElement.append(toggleVideo);

        let toggleAudio = document.createElement("input");
        toggleAudio.type = "checkbox"
        toggleAudio.checked = "checked"
        toggleAudio.value = "1"
        toggleAudio.id = "toggle_audio_" + ID;
        toggleVideo.class = "player-media-controls--audio-toggle";
        toggleAudio.addEventListener('change', (e) => e.target.checked ? players.enableAudio(ID) : players.disableAudio(ID))
        playerElement.append(toggleAudio);

        document.getElementById("players").append(playerElement);
    }

    function playerLeft(ID) {
        players.removePlayer(ID);
        document.getElementById("player_" + ID).remove();
    }

    function updateName(ID, newName) {
        let name = players.getName(ID);
        if (name !== newName) {
            players.setName(ID, newName);
            document.getElementById("player_label_" + ID).innerText = newName;
        }
    }

    function updatePlayers(Players) {
        // check for new players
        for (ID in Players) {
            if (!Players.hasOwnProperty(ID)) {
                continue;
            }
            if (players.has(ID)) {
                updateName(ID, Players[ID]);
            } else {
                players.setName(ID, Players[ID]);
                newPlayer(ID)
                if (!players.hasPeerConnection(ID)) {
                    makeCall(ID);
                }
            }
        }

        // check for removed players
        let playerIDs = players.getIDs();
        for (key in playerIDs) {
            let id = playerIDs[key];
            if (id in Players) {

            } else {
                let name = players.getName(id);
                playerLeft(id, name);
            }
        }
    }

    function startGame() {
        ws = new WebSocket(wsUrl);
        var messageBuffer = "";
        ws.onopen = function (evt) {
            console.log("opened channel");
        };
        ws.onmessage = function (evt) {
            const messages = [];
            let buffer = "";
            messageBuffer += evt.data;
            for (let i = 0; i < messageBuffer.length; i++) {
                const char = messageBuffer[i];
                buffer += char;
                if (char === "\n") {
                    messages.push(buffer);
                    buffer = "";
                }
            }
            messageBuffer = buffer;

            for (const k in messages) {
                if (!messages.hasOwnProperty(k)) {
                    continue;
                }
                const message = messages[k];
                const data = JSON.parse(message);
                switch (data.Type) {
                    case "WHATS_YOUR_NAME":
                        myPlayerID = data.Payload.ID;
                        let userInputNickName = "";
                        while (userInputNickName === "") {
                            userInputNickName = prompt(data.Payload.Message, getRandomName());
                        }

                        const answer = {Type: 'MY_NAME_IS', 'Payload': {'Name': userInputNickName}};
                        ws.send(JSON.stringify(answer));
                        break;

                    case "STATE_UPDATE":
                        let Players = data.Payload.Players;

                        updatePlayers(Players);

                        break;
                    case "WEB_RTC_OFFER":
                        console.log("received an offer from " + data.Payload.RemotePlayerID, data.Payload.Offer);
                        answerCall(data.Payload.RemotePlayerID, data.Payload.Offer);
                        break;
                    case "WEB_RTC_ANSWER":
                        console.log("received an answer from " + data.Payload.RemotePlayerID, data.Payload.Answer);
                        establishConnection(data.Payload.RemotePlayerID, data.Payload.Answer);
                        break;
                    case "WEB_RTC_ICE_CANDIDATE":
                        addIceCandidate(data.Payload.RemotePlayerID, data.Payload.IceCandidate)
                }
            }
            ws.onclose = function (evt) {
                //TODO: handle this
                console.log("closed channel");
                console.log(evt)
            };
            ws.onerror = function (evt) {
                //TODO: handle error
                console.log("error");
                console.log(evt)
            };
        };
    }

    startGame();

</script>
</body>
</html>